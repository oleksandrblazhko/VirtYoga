# Лекція 12: Основні теореми про границі та важливі границі

**Назва лекції:** «Основні теореми про границі. Ознаки існування границь. Перша важлива границя. Друга важлива границя».

**Назва практичного заняття:** «Перша і друга важливі границі».

**Пов'язаний розділ з `Docs\Lecture_1_4.txt`:** 7.1, 7.2, 7.3 (Арифметичні властивості границь, друга чудова границя).

---

### Обґрунтування користі для IT-проєкту

-   **Арифметичні властивості границь:** Ці теореми є "робочими інструментами" для програміста. Вони дозволяють розбивати складні задачі на простіші. Якщо програма аналізує комплексну метрику (наприклад, "стабільність", яка залежить від положення, швидкості та прискорення), вона може обчислити границю кожного компонента окремо, а потім об'єднати результати. Це робить код більш модульним, читабельним і легким для тестування. `lim(f+g) = lim(f) + lim(g)`.
-   **Перша важлива границя (`lim sin(x)/x = 1` при `x→0`):** Це основа для лінеаризації рухів. При аналізі малих коливань або корекцій, складні тригонометричні залежності між кутом повороту суглоба і зміною координат можна замінити на прості лінійні. Це значно прискорює обчислення і робить реакцію програми на дії користувача майже миттєвою, що є критичним для якісного зворотного зв'язку.
-   **Друга важлива границя (число `e`):** Як зазначалося раніше, ця границя є основою для моделювання процесів, що розвиваються за експоненційним законом (втома, навчання, плавна анімація).

---

### Зв'язок математичної формалізації із описом IT-проєкту

| Елемент опису IT-проєкту | Математична формалізація |
| :--- | :--- |
| Обчислення комплексної метрики пози | **Арифметичні властивості границь** (Теорема 7.1.5, 7.3.4). Границя суми/добутку дорівнює сумі/добутку границь. |
| Аналіз малих кутових коливань | **Перша важлива границя**. `sin(α) ≈ α` для малих кутів `α`. Це дозволяє замінити тригонометрію на лінійну алгебру. |
| Розрахунок траєкторії для "тонкого налаштування" пози | **Перша важлива границя**. Зміна `Δx` кінцевої точки кінцівки довжиною `L` при малому повороті на кут `Δα` дорівнює `Δx ≈ L * sin(Δα) ≈ L * Δα`. |
| Моделювання плавного згасання підказки | **Друга важлива границя**. Прозорість візуальної підказки може змінюватись за законом `opacity(t) = e⁻ᵏᵗ`. |

---

### Приклади математичного опису IT-проєкту

**1. Декомпозиція аналізу пози (Арифметичні властивості):**

-   **Завдання:** Програма оцінює "енергію" пози `E(t)`, яка спрощено може залежати від висоти центру ваги `h(t)` та квадрату швидкості його коливань `v²(t)`. `E(t) = k₁*h(t) + k₂*v²(t)`.
-   **Аналіз:** Щоб знайти стабільне значення енергії `lim E(t)`, програмі не потрібно аналізувати всю складну функцію одразу. Завдяки теоремі про границю суми та добутку, вона може зробити це по частинах:
    `lim E(t) = lim(k₁*h(t)) + lim(k₂*v²(t)) = k₁*lim h(t) + k₂*(lim v(t))²`.
-   Програма знаходить окремо границю висоти (цільова висота) і границю швидкості (має бути 0), а потім легко обчислює фінальний результат.

**2. Прискорення обчислень для малих корекцій (Перша важлива границя):**

-   **Завдання:** Користувач майже досяг цільової пози, але його рука відхилена на дуже малий кут `α` (наприклад, 0.5 градуса ≈ 0.0087 радіан). Програмі потрібно розрахувати, на скільки сантиметрів `Δy` треба змістити кисть.
-   **Точна формула:** `Δy = L * (1 - cos(α))`, де L - довжина руки.
-   **Проблема:** Обчислення косинуса є відносно повільною операцією.
-   **Рішення:** З першої важливої границі випливає, що для малих `α`, `cos(α) ≈ 1 - α²/2`. Тоді `Δy = L * (1 - (1 - α²/2)) = L * α²/2`.
-   **Ще краще:** Якщо `α` дуже малий, зміщення по осі `y` є величиною другого порядку малості, а зміщення по осі `x` буде `Δx = L * sin(α) ≈ L * α`. Це лінійне співвідношення.
-   **Результат:** Програма використовує просте і швидке множення замість тригонометричних функцій, що дозволяє їй швидше реагувати, коли користувач робить фінальні, "ювелірні" правки пози.

**3. Плавне зникнення підказки (Друга важлива границя):**

-   **Завдання:** Коли користувач виправляє помилку, візуальна підказка (наприклад, стрілка) має плавно зникнути.
-   Нехай `Error(t)` - поточна помилка. Прозорість стрілки `Opacity(t)` можна задати як `Opacity(t) = 1 - e^(-k * Error(t))`.
-   **Аналіз:**
    -   Коли помилка велика (`Error → ∞`), `e^(-k*Error) → 0`, отже `Opacity → 1` (стрілка повністю видима).
    -   Коли користувач виправляє позу і помилка прямує до нуля (`Error → 0`), то `e^(-k*Error) → 1`, отже `Opacity → 0` (стрілка плавно зникає).
-   Це створює приємний, інтуїтивно зрозумілий візуальний ефект, математична основа якого - властивості експоненційної функції, тісно пов'язаної з числом `e`.
